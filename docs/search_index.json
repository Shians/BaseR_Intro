[
["index.html", "Introduction to Base R Chapter 1 Preface", " Introduction to Base R Lucy Liu 2019-03-20 Chapter 1 Preface "],
["session-1.html", "Chapter 2 Session 1 2.1 R and RStudio 2.2 Help 2.3 R scripts 2.4 Working directory 2.5 Maths 2.6 Comparisons 2.7 Variables 2.8 Data structures 2.9 Reading in data 2.10 Data types 2.11 Vectorisation 2.12 Writing out data 2.13 Homework 2.14 Answers", " Chapter 2 Session 1 2.1 R and RStudio R is a free and open source statistical programming language, great for performing data analysis. RStudio is a free and open source R integrated development environment (IDE) which makes it easier for you to write code. It does this by providing you with auto-completion (of variable names, function names, file paths etc.), helping with formatting and keeping track of your variables. You can think of R as the engine in a car and RStudio as the body &amp; controls. R is doing all the calculations/computations but RStudio makes it easier for you to use R. When you first open RStudio, there will be three panels - see Figure 2.1 (don’t worry if your RStudio does not have the same colours/appearance - different versions of RStudio look slightly different and the text colour I use is not the default one.) Figure 2.1: Three panels in RStudio. Left panel: this panel features two tabs, ‘Console’, which is where you can type in commands for R to run and ‘Terminal’, which we won’t worry about in this course. Top right panel: Environment - in this tab you can see all variables you have created. History - R keeps track of all commands you have run and you can review them in this tab. Connections - this tab helps you connect to data sources but we will not be using it in this course. Bottom right: Files - you can explore your file directory here and we will use it to set our working directory later. Plots - plots that you create will either appear here or be saved to a file. Help - help files for R functions can be viewed in this tab. Help files tell you about what a function does and how to use it. Packages - basic R includes many useful functions. You can add even more functions by downloading packages. A package is a collection of functions, generally with a certain data analysis theme. For example, the package ‘limma’, which we will use later, includes functions designed for analysing RNA-sequencing data. Viewer - this tab lets you view local web content but we won’t be using it in this course. 2.2 Help There are two ways to access help files in RStudio. You can type in the name of the function you want help with, in the top right of help tab (indicated with a red arrow): Figure 2.2: Accessing help files via ‘help’ tab. The other option is to run the command ? followed by the name of the function: ?sum Help files are very useful but can be difficult to interpret at first due to the technical language used. We won’t get too much practice reading help files during this course but I would encourage you to try to use them when figuring out how to use a new function. 2.3 R scripts To open a R script, go to File &gt; New File &gt; R Script. Figure 2.3: Opening a new R Script. This will open a fourth panel on the top left. Figure 2.4: Four panels, including a R Script. A R Script is just a text document. You can type and run commands using a R Script and down in the Console - the difference is that you can’t save the commands you run in the Console but you can save the R Script with all your commands. Note that to run a command in the Console press Enter key but to run a command in a R Script you must press Cmd/Cntrl + Enter keys. Lastly, you can make ‘comments’ in your R Script. Comments are notes to yourself that are not interpreted by R and start with #: # this is a note to myself 1+3-2 ## [1] 2 2.4 Working directory Every file on your computer is located in a specific location. This location can be referred to by a path. In Mac, paths look something like this: /Users/Lucy/Documents/. In Windows, paths look something like this: C:\\Users\\Lucy\\Documents\\. When you open a R session, it launches from a specific location. You can find out where this is using the command getwd(). This location called the ‘working directory’. R will, by default, look in this directory when reading in data and write out files/plots to this directory. It is often useful to have your data and R Scripts in the same directory and set this as your working directory. You can set your working directory to be anywhere you like and we will now do this: Make a folder for this course, somewhere sensible on your computer that you will be able to easily find. Go back to your RStudio window, go to the bottom right panel, click on the ‘Files’ tab and then click on the three dots on the top right hand corner (Figure 2.5). Figure 2.5: Setting the working directory - 1. This will open up a new window (Figure 2.6) which lets you explore the files and folders on your computer. Find the new folder you created, click on it then click ‘Open’. Figure 2.6: Setting the working directory - 2. The files tab will now show the contents of your new folder (which should be empty). At the top of the files tab, click on More &gt; Set As Working Directory (Figure 2.7). Figure 2.7: Setting the working directory - 3. 2.5 Maths R performs maths and follows standard order of operations. In order of highest to lowest precedence, here is how mathematical operations are denoted in R: () - parentheses ** or ^ - exponents / - divide * - multiply + - add - - subtract Another useful function is modulus (%%), which gives the remainder after dividing: 8%%3 ## [1] 2 2.6 Comparisons You can also compare numbers in R: 1 == 1 # equal to. ## [1] TRUE 2 &gt; 1 # greater than. ## [1] TRUE 2 &lt; 1 # less than. ## [1] FALSE 1 &lt;= 2 # greater or equal to. ## [1] TRUE 1 &gt;= 2 # less than or equal to. ## [1] FALSE What do you think will happen if we compare words? &quot;cat&quot; &gt; &quot;dog&quot; ## [1] FALSE R will use alphabetical order to determine which word is ‘greater’: &quot;a&quot; &lt; &quot;b&quot; ## [1] TRUE 2.7 Variables A variable in R is just a name which refers to an ‘thing’ (more technically an ‘object’ in R). For example, I can do some maths: 2 + 6 * 7**2 ## [1] 296 R outputs the result. However, if I want to ‘save’ this result to use later, I need to ‘assign’ the output to a variable. This can be thought of as giving it a name, so that we can refer to it later. You can this with &lt;- (shortcut = alt + -) in R. (You can also use =, however stylistically &lt;- is preferred.) Here R performs the calculation on the right of &lt;- and then saves the result as a variable called my_num. my_num &lt;- 2 + 6 * 7**2 Now if I run the command my_num, I see the number I stored earlier: my_num ## [1] 296 R is particular about variable names. Variable names cannot: start with a number, contain any spaces. If we try to create a variable that starts with a number, R will return us an error: 2myvar &lt;- 2 + 6 * 7**2 ## Error: &lt;text&gt;:1:2: unexpected symbol ## 1: 2myvar ## ^ 2.7.1 Errors and warnings This is a good time to talk about ‘errors’ and ‘warnings’ in R. An error is R telling you that it couldn’t do what you told it to do. Do not be disheartened at seeing an error message - it happens to everyone, including experienced programmers, all the time. DO read the error message, it is often very useful and tells you what you need to do to fix the error. A warning is R telling you that is has done what you told it to do, however the result may not be what you want. Sometimes it is okay to ignore a warning, sometimes it is not! 2.8 Data structures A data structure can be thought of as a ‘container’ for data. There are a number of different data structures in R and each have different specifications about how data is ‘contained’. Three commonly used data structures are summarised below: Figure 2.8: Data structures. Source: http://libguides.wellesley.edu. Another useful data structure is a ‘list’, which we will talk about in Session 3. 2.8.1 Vector You can think of a vector like a row or column in excel. You can only store one type of data in a vector - e.g. all numbers or all text. You can create vectors with the c() function (‘c’ for ‘combine’): my_vect1 &lt;- c(1,2,3) my_vect2 &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) 2.8.2 Matrix A matrix is like an excel spreadsheet. It is two dimensional meaning you have columns and rows of data. You can only store one type of data in a matrix - e.g. all numbers or all text. 2.8.3 Dataframe Dataframes are also two dimensional (has both rows and columns) however, you can store different types of data in a dataframe. The only restriction is that all the data within one column must be of the same type. 2.9 Reading in data Let’s read in some data and start exploring it. You should have received the data files via email before the course. Please download these files and make sure they are located in your working directory. Recall, we set our working directory above. You can find the location of your working directory with the function getwd(). If you are following along outside of the WEHI course, you can download the data files from Github - instructions for downloading data from GitHub can be found in the Preface. The file we want to read in is named ‘Ses1_genes.tsv’. I have put all my data files in a directory called ‘data’ - thus the path to the file (relative to my working directory) is ‘data/Ses1_genes.tsv’. Depending on where you have put your data (in your working directory or in another file in your working directory), the path to your file ‘Ses1_genes.tsv’ may be different. Read in your data by typing in the path to your ‘Ses1_genes.tsv’ file (relative to your working directory), within the brackets ( ): read.delim(&quot;data/Ses1_genes.tsv&quot;) ## SYMBOL GeneLength Count ## 1 Gm10568 1634 0 ## 2 Gm19860 799 4 ## 3 Gm19938 3259 0 ## 4 Lypla1 2433 768 ## 5 Rp1 9747 0 ## 6 Sox17 3130 1 ## 7 Tcea1 2847 810 ## 8 Mrpl15 4203 431 ## 9 Xkr4 3634 1 ## 10 Rgs20 2241 452 Note that read.delim() also lets you specify what kind of file you are reading in - by this I mean how each value is separated. Two common formats are ‘csv’ (comma separated values) and ‘tsv’ (tab separated values). Example of csv file: Name, Age Andy, 10 Bob, 8 Example of tsv file: Name Age Andy 10 Bob 8 Note how the values in each file are separated by a different ‘character’ in the two file formats. You can specify what using the sep input in read.delim(). E.g. if your file was a csv, you can read it in using: read.delim(&quot;file.csv&quot;, sep = &quot;,&quot;) We don’t need to specify the sep for our file, which is a tsv, as the default separater read.delim() assumes is tab. Thus we only need to specify when we are reading in a file NOT separated by tabs. Above, we have read in our data as a dataframe and printed it. However, we can’t refer to this dataframe again and manipulate it because we haven’t assigned it to a variable. Let’s assign our dataframe to a variable called genes: genes &lt;- read.delim(&quot;data/Ses1_genes.tsv&quot;) Notice how genes now appears in our ‘Environment’ tab: Figure 2.9: Variable in ‘Environment’ tab. All variables that we create will be shown in this tab, so it is a useful way to keep track of variables that we have created. Notice how R also tells us that there are 10 observations (rows) and 3 variables (columns) in the genes dataframe. We can further explore our dataframe with the function str() (structure): str(genes) ## &#39;data.frame&#39;: 10 obs. of 3 variables: ## $ SYMBOL : Factor w/ 10 levels &quot;Gm10568&quot;,&quot;Gm19860&quot;,..: 1 2 3 4 7 8 9 5 10 6 ## $ GeneLength: int 1634 799 3259 2433 9747 3130 2847 4203 3634 2241 ## $ Count : int 0 4 0 768 0 1 810 431 1 452 This tells us that genes is a dataframe. It also tells us what data type each column is. 2.10 Data types Every bit of data in R has a ‘data type label’. The label doesn’t change the data in any way - it just tells R what kind of data it is and thus what it can and can’t do with the data. For example, it makes sense to perform mathematical functions on numbers but not on words. It makes sense to look for a certain term, like a gene name, in a word but not in a number. There are five basic types of data in R: logical - either TRUE or FALSE. This is useful for data that only has two possible values, like if patient has a disease or not. integer - number without decimal point e.g. 3. double - number with decimal point e.g. 3.14. complex - complex number with a real and imaginary part e.g. 1 + 3i character - Anything with character(s) within it. Quotes (double or single) signify this data type e.g. &quot;pi&quot;. Also known as a ‘string’. In our genes dataframe above, we can see that both the GeneLength and Count columns are integers (‘int’). But what is the SYMBOL column? It is a ‘Factor’. 2.10.1 Factors Factor is a data type label used for categorical variables (e.g. small, medium and large OR red, blue and green). Internally, R stores factors as numbers (integers), with each number corresponding to a category. For example, if your data was: red, blue, green, red, green Internally, R would store the data as: 1, 2, 3, 1, 3 Each number corresponds to a category. This information is also stored. R calls the categorical value each number corresponds ‘levels’. The levels for the above data would be: 1 = red 2 = blue 3 = green Factors can be difficult to work with, so we don’t want our gene symbols to be ‘labelled’ as factors. We can do this by specifying this when reading our data in: genes &lt;- read.delim(&quot;data/Ses1_genes.tsv&quot;, stringsAsFactors = FALSE) By default, R will label all word (‘character’) data as a ‘factor’. Setting stringsAsFactors to be FALSE, tells R that you DON’T want it to do this. We can check the structure again: str(genes) ## &#39;data.frame&#39;: 10 obs. of 3 variables: ## $ SYMBOL : chr &quot;Gm10568&quot; &quot;Gm19860&quot; &quot;Gm19938&quot; &quot;Lypla1&quot; ... ## $ GeneLength: int 1634 799 3259 2433 9747 3130 2847 4203 3634 2241 ## $ Count : int 0 4 0 768 0 1 810 431 1 452 Note that now the column SYMBOL is now a character (‘chr’). 2.11 Vectorisation R is quite efficient at doing calculations or performing a functions on a vector of data. Let’s use the Count column from our dataframe genes. We can access just one column using the $ symbol: genes$Count ## [1] 0 4 0 768 0 1 810 431 1 452 What do you think will happen if we do this? genes$Count + 10 ## [1] 10 14 10 778 10 11 820 441 11 462 R will perform this calculation on all numbers in the Count column and return a vector. We can add this new vector to our dataframe, as a new column. genes$Count_2 &lt;- genes$Count + 10 There are a few things happening in the command above: The code on the right side of &lt;- is evaluated first. It returns a vector as we saw above. This vector is assigned to a column in genes called Count_2. Since this column does not yet exist in the genes dataframe, a new column called Count_2 is created first. (If there was already a column name Count_2, this command will have overwritten that column with the new vector created in the right side of &lt;-) Challenge 1 Create a new column called Prop_Count that contains each count value as a proportion of the total count value of all 10 genes in the dataframe. E.g. if Count was 10 and total count of all 10 genes is 100, that row in Prop_Count should be 0.1. Hint use the sum() function. 2.12 Writing out data The last thing we will do this session is to write out our new dataframe using the function write.table(). There are a few things we must tell write.table(), for it to be able to write out the data the way we want: x - the name of this input is not very informative, but first you must tell the function what you want to write out. In our case we want to write out our dataframe genes. file - the name of the file that we want to write to. sep - how each value in our output file is separated. Common file formats are ‘csv’ and ‘tsv’ (discussed above). In R, a tab is represented by &quot;\\t&quot;. row.names - this is either TRUE or FALSE, and let’s you specify whether you want to write out row names. If your dataframe does not have row names, put FALSE. col.names - this is also either TRUE or FALSE, and let’s you specify whether you want to write out column names. If your dataframe has column names, put TRUE. write.table(x = genes, file = &quot;Ses1_Genes_output.tsv&quot;, sep = &quot;\\t&quot;, row.names = FALSE, col.names = TRUE) 2.13 Homework Read in the data file “Ses1_homework.tsv” using read.delim(). This file is similar to the “Ses1_genes.tsv” file but with a different 10 genes. Create a new column called Prop_GeneLength that contains the Count value as a proportion of GeneLength. E.g. if the count value was 50 and the gene length was 2400, the Prop_GeneLength value for that row would be 0.02083333. Now write out this new dataframe as a file called “Ses1_homework_output.tsv”, as a tsv (tab separated values) file. 2.14 Answers Challenge 1 The sum() function can be used to calculate the total Count of all 10 rows by giving the genes$Count vector as the input to sum(). genes$Prop_Count &lt;- genes$Count / sum(genes$Count) genes ## SYMBOL GeneLength Count Count_2 Prop_Count ## 1 Gm10568 1634 0 10 0.0000000000 ## 2 Gm19860 799 4 14 0.0016214025 ## 3 Gm19938 3259 0 10 0.0000000000 ## 4 Lypla1 2433 768 778 0.3113092825 ## 5 Rp1 9747 0 10 0.0000000000 ## 6 Sox17 3130 1 11 0.0004053506 ## 7 Tcea1 2847 810 820 0.3283340089 ## 8 Mrpl15 4203 431 441 0.1747061208 ## 9 Xkr4 3634 1 11 0.0004053506 ## 10 Rgs20 2241 452 462 0.1832184840 "],
["session-2.html", "Chapter 3 Session 2 3.1 Missing values 3.2 Subsetting 3.3 Merge 3.4 Functions 3.5 Homework 3.6 Answers", " Chapter 3 Session 2 Last session we gained an understanding of R data structures and data types. In this session we will learn about: missing values subsetting data structures how to merge two dataframes how functions are created and used 3.1 Missing values First, let’s read in some data, then subset it. Recall we use the function read.delim() and tell R not to label words as ‘Factors’ using stringsAsFactors = FALSE. genes &lt;- read.delim(&quot;data/Ses2_genes.tsv&quot;, stringsAsFactors = FALSE) You can see in the environment tab that this dataframe has 200 rows (observations) and 5 columns (variables). You can also click on the genes entry in the Environment tab (red arrow in Figure 3.1) to display the data in a new window (left): Figure 3.1: Viewing data from the ‘Environment’ tab. Scrolling down the window, you can see that there are several NA entries. NA denotes a missing value in R. NA‘s have some interesting behaviour - the are ’contagious’. For example, if we wanted to take the mean of a vector numbers, which includes a NA, the answer is NA. If we think about it, it makes sense that the mean of two numbers and a ‘missing’ number that could be anything is NA. mean(c(2,3,NA)) ## [1] NA Luckily many functions have a na.rm input, where you can tell it to remove NA values: mean(c(2,3,NA), na.rm = TRUE) ## [1] 2.5 Later we will learn how to remove the NA values from our dataframe. 3.2 Subsetting Subsetting involves selecting a portion of a data structure and uses square brackets [ ]. There are two main ways to subset a data structure: Use indices - data structures are all ordered and ‘numbered’ in R. This means that you can refer to the 4th element in a vector or the element in the 1st row and 3rd column of a dataframe. Use logicals - recall that a logical is TRUE or FALSE. You can use comparisons (e.g. equal to ==, greater than &gt;) to determine if each element in your data structure meet your requirements. 3.2.1 Subsetting with indicies Let’s take a look at subsetting vectors first. We can use $ to obtain just one column from the genes dataframe. The output will be a vector. genes$Count ## [1] 979 15 932 0 214 2 2 0 1790 41 1033 ## [12] 700 2075 351 22 0 0 893 3 100 32100 269 ## [23] 34 20005 5751 0 275 9 849 7175 768 358 234 ## [34] 5065 2096 1994 757 0 2310 0 1 0 3091 810 ## [45] 30 816 817 1 580 33 0 941 1445 522 2 ## [56] 2346 572 431 5797 2 70 1236 966 235 2 3009 ## [67] 431 452 2602 3481 99 11857 35 1952 0 706 1317 ## [78] 1130 92 0 871 730 3892 3772 20 7 0 756 ## [89] 1 210 101 17 21 537 1240 930 1 1 0 ## [100] 221 1599 0 67 1 0 315 0 0 739 0 ## [111] 0 976 1 715 18636 289 1396 0 101 285 1665 ## [122] 47 2 4483 2 363 169 135 0 2 0 11 ## [133] 4088 1082 92 0 3888 17 0 0 0 0 0 ## [144] 0 0 0 0 0 2442 30 1610 0 0 0 ## [155] 16 1 2 0 47 0 1118 0 1 0 2 ## [166] 3 22 0 0 0 0 0 0 0 431 0 ## [177] 0 16 0 1 0 4 0 0 1 0 0 ## [188] 0 0 301 0 0 0 0 0 0 0 0 ## [199] 0 59 We will assign this to a variable called Counts. Counts is now a variable that refers to a vector containing 200 integers. Counts &lt;- genes$Count This will give you the 3rd element of the vector Counts: Counts[3] ## [1] 932 This will give you all the elements from the 3rd to the 10th: Counts[3:10] ## [1] 932 0 214 2 2 0 1790 41 This will give you the 3rd, 5th and 10th elements: Counts[c(3,5,100)] ## [1] 932 214 221 Note that we have used c() within the square brackets. This is because R expects ONE ‘object’ within the square brackets. Thus, if you want to extract several indices, you must give it ONE vector containing the indices of the elements. A vector (e.g. c(3,5,10)) is considered one ‘object’ but the numbers 3,5,10 are considered three different ‘objects’. Indeed, 3:10, which we used earlier, is actually a vector of the numbers 3 to 10: 3:10 ## [1] 3 4 5 6 7 8 9 10 Lastly, this gives you all the elements EXCEPT the elements 10 through to 200: Counts[-(10:200)] ## [1] 979 15 932 0 214 2 2 0 1790 Subsetting a dataframe is similar to subsetting a vector, except you now must specify which rows AND which columns you want. The syntax looks like this: genes[ (which rows you want) , (which columns you want) ] Within the square brackets, you must first tell R which rows you want LEFT of the comma, then which columns you want RIGHT of the comma. The code below will give you the 3rd to 5th rows of the 2nd and 4th columns. Note that the output is a dataframe. genes[3:5,c(2,4)] ## SYMBOL GeneLength ## 3 Bmp2 2515 ## 4 Cacna1e 12697 ## 5 Ccnf 3099 We could have also done this using the names of the columns. Note that column names are enclosed in quotes signifying that they are of the ‘character’ data type. genes[3:5,c(&quot;SYMBOL&quot;,&quot;GeneLength&quot;)] ## SYMBOL GeneLength ## 3 Bmp2 2515 ## 4 Cacna1e 12697 ## 5 Ccnf 3099 If you leave the left side of comma empty, R will give you ALL the rows. If you leave the right side of the comma empty, R will give you ALL the columns. This will give you the 2nd row and all the columns. genes[2,] ## EntrezID SYMBOL TXCHROM GeneLength Count ## 2 11634 Aire chr10 1929 15 3.2.2 Subsetting with logicals If you recall from section 2.6, you can make comparisons in R. The result of a comparison is either TRUE or FALSE: 1 &lt; 2 ## [1] TRUE Comparisons are also vectorised: genes$Count &lt; 100 ## [1] FALSE TRUE FALSE TRUE FALSE TRUE TRUE TRUE FALSE TRUE FALSE ## [12] FALSE FALSE FALSE TRUE TRUE TRUE FALSE TRUE FALSE FALSE FALSE ## [23] TRUE FALSE FALSE TRUE FALSE TRUE FALSE FALSE FALSE FALSE FALSE ## [34] FALSE FALSE FALSE FALSE TRUE FALSE TRUE TRUE TRUE FALSE FALSE ## [45] TRUE FALSE FALSE TRUE FALSE TRUE TRUE FALSE FALSE FALSE TRUE ## [56] FALSE FALSE FALSE FALSE TRUE TRUE FALSE FALSE FALSE TRUE FALSE ## [67] FALSE FALSE FALSE FALSE TRUE FALSE TRUE FALSE TRUE FALSE FALSE ## [78] FALSE TRUE TRUE FALSE FALSE FALSE FALSE TRUE TRUE TRUE FALSE ## [89] TRUE FALSE FALSE TRUE TRUE FALSE FALSE FALSE TRUE TRUE TRUE ## [100] FALSE FALSE TRUE TRUE TRUE TRUE FALSE TRUE TRUE FALSE TRUE ## [111] TRUE FALSE TRUE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE ## [122] TRUE TRUE FALSE TRUE FALSE FALSE FALSE TRUE TRUE TRUE TRUE ## [133] FALSE FALSE TRUE TRUE FALSE TRUE TRUE TRUE TRUE TRUE TRUE ## [144] TRUE TRUE TRUE TRUE TRUE FALSE TRUE FALSE TRUE TRUE TRUE ## [155] TRUE TRUE TRUE TRUE TRUE TRUE FALSE TRUE TRUE TRUE TRUE ## [166] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE FALSE TRUE ## [177] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [188] TRUE TRUE FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [199] TRUE TRUE For each element in the vector genes$Count, R checks if it is less than 100, then returns either TRUE or FALSE. The output is a vector of logicals. This can be used to subset in R. We will start with our Counts vector: Counts[Counts &lt; 100] ## [1] 15 0 2 2 0 41 22 0 0 3 34 0 9 0 0 1 0 30 1 33 0 2 2 ## [24] 70 2 99 35 0 92 0 20 7 0 1 17 21 1 1 0 0 67 1 0 0 0 0 ## [47] 0 1 0 47 2 2 0 2 0 11 92 0 17 0 0 0 0 0 0 0 0 0 0 ## [70] 30 0 0 0 16 1 2 0 47 0 0 1 0 2 3 22 0 0 0 0 0 0 0 ## [93] 0 0 16 0 1 0 4 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [116] 59 Counts &lt; 100 will return a vector of 200 logicals, which indicate which elements are less than 100. Putting this inside square brackets will subset Counts such that only the elements that are less than 100 (the TRUE’s) remain. This is done similarly in dataframes. The command below selects the rows where the genes$Count column equal to 0. genes[genes$Count == 0,] Because there are so many rows with a genes$Count of 0, I’ll use the head() function to print out just the first 6 rows of the output: head(genes[genes$Count == 0,]) ## EntrezID SYMBOL TXCHROM GeneLength Count ## 4 12290 Cacna1e chr1 12697 0 ## 8 12647 Chat chr14 2810 0 ## 16 14800 Gria2 chr3 7749 0 ## 17 14843 Gsx2 chr5 1665 0 ## 26 17695 Msmb chr14 522 0 ## 38 19888 Rp1 chr1 9747 0 If you add ! to the start of the genes$Count == 0 condition statement, you will get all the rows where genes$Count is NOT equal to 0. Another way to think about it is that genes$Count == 0 gives you a logical vector of 200 TRUE’s and FALSE’s and ! flips everything such that the TRUE’s become FALSE’s and vice versa. We do this here and print the first 6 rows of the output: head(genes[! genes$Count == 0,]) ## EntrezID SYMBOL TXCHROM GeneLength Count ## 1 11480 Acvr2a chr2 5681 979 ## 2 11634 Aire chr10 1929 15 ## 3 12156 Bmp2 chr2 2515 932 ## 5 12449 Ccnf chr17 3099 214 ## 6 12563 Cdh6 chr15 2632 2 ## 7 12565 Cdh9 chr15 2903 2 Challenge 2.1 Subset the genes dataframe to obtain the rows where the Count is less than or equal to 10 and the columns TXCHROM and Count. The function is.na() checks if each element in a vector is NA: is.na(c(2,5, NA)) ## [1] FALSE FALSE TRUE Use this function to subset the genes dataframe so that all rows where TXCHROM column is NA is removed. Using the dataframe from above subset to get only the rows where the TXCHROM is ‘chr1’ and all columns. Hint: you can refer to section 2.6 to check how to perform different types of comparisons in R. 3.2.3 %in% In the last challenge, we used == to obtain the rows where TXCHROM is ‘chr1’. Another way to perform ‘matching’ tasks is with the %in% function. The following command subsets the rows where TXCHROM is “chr1” or “chr2” and prints out the first 6 rows. head( genes[genes$TXCHROM %in% c(&quot;chr1&quot;, &quot;chr2&quot;),] ) ## EntrezID SYMBOL TXCHROM GeneLength Count ## 1 11480 Acvr2a chr2 5681 979 ## 3 12156 Bmp2 chr2 2515 932 ## 4 12290 Cacna1e chr1 12697 0 ## 18 15064 Mr1 chr1 2509 893 ## 19 15112 Hao1 chr2 2029 3 ## 21 15939 Ier5 chr1 3270 32100 Challenge 2.2 There is an important difference between == and %in%. Let’s start by creating a vector of numbers: vect1 &lt;- c(10,10,5,5,8,8) We check which elements in our vector is equal to 5. vect1 == 5 ## [1] FALSE FALSE TRUE TRUE FALSE FALSE The output is what we would expect. What if we wanted check which elements are equal to 5 OR 10? We might try something like this, where put the numbers we are checking for in a vector: vect1 == c(5,10) ## [1] FALSE TRUE TRUE FALSE FALSE FALSE This output isn’t what we want. Let’s try the same task with %in%: vect1 %in% c(5,10) ## [1] TRUE TRUE TRUE TRUE FALSE FALSE This output IS what we want. Take a look at the code above and see if you can understand what == does and what %in% does. Hint: The story gets even more interesting if we try to use == to look for four numbers: vect1 == c(5,10,1,3) ## Warning in vect1 == c(5, 10, 1, 3): longer object length is not a multiple ## of shorter object length ## [1] FALSE TRUE FALSE FALSE FALSE FALSE This warning message may seem a bit cryptic. The ‘longer’ object it is referring to is vect1 which has 6 elements. The shorter object it is referring to is c(5,10,1,3), which has 4 elements. Thus, it is saying that 6 is not a multiple of 4. The reason R wants the longer object to be a multiple of the shorter one, is key to understanding what is happening when we use ==. 3.3 Merge Two dataframes can be combined with the merge() function. First, let’s read in the file “Ses2_geneNames.tsv”, which contains gene names and their corresponding ENTREZIDs. gene_names &lt;- read.delim(&quot;data/Ses2_geneNames.tsv&quot;, stringsAsFactors = FALSE) What we want to do now, is to add the GENENAME column from gene_names dataframe to the genes dataframe. We also want to make sure that when R merges the dataframes, the correct GENENAME is added to the correct row. You will notice that both the genes and gene_names dataframes have a column giving the EntrezIDs. Thus, we want merge() to match rows using EntrezIDS while it is merging. merge() has the following syntax: merge( x = # name of the first dataframe to merge y = # name of the second dataframe to merge by.x = # name of the column to match, in the first dataframe by.y = # name of the column to match in the second dataframe ) Thus, to merge our two dataframes we can use: genes2 &lt;- merge(x = genes, y = gene_names, by.x = &quot;EntrezID&quot;, by.y = &quot;ENTREZID&quot;) head(genes2) ## EntrezID SYMBOL TXCHROM GeneLength Count ## 1 11480 Acvr2a chr2 5681 979 ## 2 11634 Aire chr10 1929 15 ## 3 12156 Bmp2 chr2 2515 932 ## 4 12290 Cacna1e chr1 12697 0 ## 5 12449 Ccnf chr17 3099 214 ## 6 12563 Cdh6 chr15 2632 2 ## GENENAME ## 1 activin receptor IIA ## 2 autoimmune regulator (autoimmune polyendocrinopathy candidiasis ectodermal dystrophy) ## 3 bone morphogenetic protein 2 ## 4 calcium channel, voltage-dependent, R type, alpha 1E subunit ## 5 cyclin F ## 6 cadherin 6 Challenge 2.3 You may have noticed that there are 200 rows in the genes dataframe but 290 rows in the gene_names dataframe. This means that there are more gene names contained. We can also specify which rows to keep when merging: merge( x = # name of the first dataframe to merge y = # name of the second dataframe to merge by.x = # name of the column to match, in the first dataframe by.y = # name of the column to match in the second dataframe all.x = # logical. If TRUE, keep all rows from the first dataframe, even if does not have a matching row in the second dataframe all.y = # logical. If TRUE, keep all rows from the second dataframe, even if does not have a matching row in the second dataframe ) Merge the two dataframes again, but this time keep all rows from both dataframes. 3.4 Functions A function, as the namne suggests performs a function. We have already used many functions. For example, the read.delim() function reads in data, the sum() function adds numbers up and the merge() function above merges two dataframes. Formally, when using a function, always include brackets (( )) after the name of the function. Within the brackets is where input (technically ‘arguments’) to the function goes. For example, 3.5 Homework 3.6 Answers Challenge 2.1 This code obtains rows where Count is less than or equal to 10 and prints the first 6 rows using head(): head(genes[genes$Count &lt;= 10,]) ## EntrezID SYMBOL TXCHROM GeneLength Count ## 4 12290 Cacna1e chr1 12697 0 ## 6 12563 Cdh6 chr15 2632 2 ## 7 12565 Cdh9 chr15 2903 2 ## 8 12647 Chat chr14 2810 0 ## 16 14800 Gria2 chr3 7749 0 ## 17 14843 Gsx2 chr5 1665 0 This code removes all rows where the TXCHROM column has a NA value (keeping all columns) and prints the first 6 rows: head(genes[! is.na(genes$TXCHROM),]) ## EntrezID SYMBOL TXCHROM GeneLength Count ## 1 11480 Acvr2a chr2 5681 979 ## 2 11634 Aire chr10 1929 15 ## 3 12156 Bmp2 chr2 2515 932 ## 4 12290 Cacna1e chr1 12697 0 ## 5 12449 Ccnf chr17 3099 214 ## 6 12563 Cdh6 chr15 2632 2 First we save the dataframe from the above as a variable called genes_noNA, then we subset to get only the rows where TXCHROM is ‘chr1’. Again we only print the first 6 rows of this output. genes_noNA &lt;- genes[! is.na(genes$TXCHROM),] head(genes_noNA[genes_noNA$TXCHROM == &quot;chr1&quot;,]) ## EntrezID SYMBOL TXCHROM GeneLength Count ## 4 12290 Cacna1e chr1 12697 0 ## 18 15064 Mr1 chr1 2509 893 ## 21 15939 Ier5 chr1 3270 32100 ## 31 18777 Lypla1 chr1 2433 768 ## 36 19775 Xpr1 chr1 7651 1994 ## 38 19888 Rp1 chr1 9747 0 Challenge 2.2 What == does is compare vect1 with c(5,10) one by one. Since c(5,10) only has two elements, R repeats this shorter vector until it is the same length as the longer vector. This is called ‘recycling’. Thus, the comparisons being made is the top row with each corresponding value in the bottom row, with the result being shown in the third row: 10 10 5 5 8 8 5 10 5 10 5 10 FALSE TRUE TRUE FALSE FALSE FALSE R gives you a warning whenever the length of the shorter vector is NOT a multiple of the longer vector. When there were 4 elements in the shorter vector, it was not repeated a whole number of times - it was repeated 1.5 times. The comparisons being made between vect1 and c(5,10,1,3) are: 10 10 5 5 8 8 5 10 1 3 5 10 FALSE TRUE FALSE FALSE FALSE FALSE %in% simply performs matching and does not take order of the two vectors into consideration. It checks whether the values in vect1 matches either number in c(5,10). It thus gives us the result we expect. Challenge 2.3 genes2 &lt;- merge(x = genes, y = gene_names, by.x = &quot;EntrezID&quot;, by.y = &quot;ENTREZID&quot;, by.x = TRUE, by.y = TRUE) "],
["session-3.html", "Chapter 4 Session 3 4.1 Lists 4.2 S4 objects 4.3 DGEList", " Chapter 4 Session 3 4.1 Lists 4.2 S4 objects 4.3 DGEList "],
["session-4.html", "Chapter 5 Session 4", " Chapter 5 Session 4 "]
]
