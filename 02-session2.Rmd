# Session 2

In this session we will learn about:

* missing values
* subsetting data structures
* how functions are created and used

## Missing values {#miss}

First, let's read in some data. Recall we use the function `read.delim()` and tell R not to label words (character type data) as 'Factors' using `stringsAsFactors = FALSE`.

We are using the file "Ses2_genes.tsv" today. This would have been emailed to you before the session. (Alternatively you can download the data from [GitHub](https://github.com/lucyleeow/BaseR_Intro)).

```{r}
genes <- read.delim("data/Ses2_genes.tsv", stringsAsFactors = FALSE)
```

You can see in the environment tab that this dataframe has 200 rows (observations) and 5 columns (variables). You can also click on the `genes` entry in the Environment tab (red arrow in Figure \@ref(fig:RS4)) to display the data in a new window (left):

```{r RS4, fig.cap="Viewing data from the 'Environment' tab.", out.width="700px", echo=FALSE}
knitr::include_graphics("Images/RS4.png")
```

Scrolling down the window, you can see that there are several *NA* entries. `NA` denotes a missing value in R.

`NA`'s have some interesting behaviour - they are 'contagious'. For example, if we wanted to take the mean of a vector numbers, which includes a `NA`, the answer is `NA`. If we think about it, it makes sense that the mean of two numbers and a 'missing' number, that could be anything, is `NA`.

```{r}
mean(c(2,3,NA))
```

Luckily many functions have a `na.rm` option, where you can tell it to remove `NA` values:

```{r}
mean(c(2,3,NA), na.rm = TRUE)
```

Later, we will learn how to remove the `NA` values from our dataframe.

## Subsetting

Subsetting involves selecting a portion of a data structure and uses square brackets `[ ]`. There are two main ways to subset a data structure:

* Use indices - data structures are all ordered and 'numbered' in R. This means that you can refer to the 4th element in a vector or the element in the 1st row and 3rd column of a dataframe. 
* Use logicals - recall that a logical is `TRUE` or `FALSE`. You can use comparisons (e.g. equal to `==`, greater than `>`) to determine if each element in your data structure meet your requirements and use this to subset your data.

### Subsetting with indicies

Let's take a look at subsetting vectors first. We can use `$` to obtain just one column from the `genes` dataframe. The output will be a vector.

```{r}
genes$Count
```

We will assign this to a variable called `Counts`. `Counts` is now a variable that refers to a vector containing 200 integers.

```{r}
Counts <- genes$Count
```

This will give you the 3rd element of the vector `Counts`:

```{r}
Counts[3]
```

This will give you all the elements from the 3rd to the 10th:

```{r}
Counts[3:10]
```

This will give you the 3rd, 5th and 10th elements:

```{r}
Counts[c(3,5,100)]
```

Note that we have used `c()` within the square brackets. This is because R expects ONE 'object' within the square brackets. Thus, if you want to extract several indices, you must give it ONE vector containing the indices of the elements. A vector (e.g. `c(3,5,10)`) is considered one 'object' but the numbers `3,5,10` are considered three different 'objects'.

Indeed, `3:10`, which we used earlier, is actually a vector of the numbers 3 to 10:

```{r}
3:10
```

Lastly, this gives you all the elements EXCEPT the elements 10 through to 200:

```{r}
Counts[-(10:200)]
```

Subsetting a 2 dimensional data structure (e.g. a dataframe or matrix) is similar to subsetting a vector, except you now must specify which rows AND which columns you want. The syntax for the `genes` dataframe looks like this:

```
genes[ (which rows you want) , (which columns you want) ]
```

Within the square brackets, you must first tell R which rows you want LEFT of the comma, then which columns you want RIGHT of the comma.

The code below will give you the 3rd to 5th rows of the 2nd and 4th columns. Note that the output is a dataframe.

```{r}
genes[3:5,c(2,4)]
```

We could have also done this using the names of the columns. Note that column names are enclosed in quotes signifying that they are of the 'character' data type.

```{r}
genes[3:5,c("SYMBOL","GeneLength")]
```


If you leave the left side of comma empty, R will give you ALL the rows. If you leave the right side of the comma empty, R will give you ALL the columns.

This will give you the 2nd row and all the columns.

```{r}
genes[2,]
```

### Subsetting with logicals

If you recall from section \@ref(comps), you can make comparisons in R. The result of a comparison is either `TRUE` or `FALSE`:

```{r}
1 < 2
```

Comparisons are also vectorised:

```{r}
genes$Count < 100
```

For each element in the vector `genes$Count`, R checks if it is less than 100, then returns either `TRUE` or `FALSE`. The output is a vector of logicals.

This can be used to subset in R. We will start with our `Counts` vector:

```{r}
Counts[Counts < 100]
```

`Counts < 100` will return a vector of 200 logicals, which indicate which elements are less than 100. Putting this inside square brackets will subset `Counts` such that only the elements that are less than 100 (the `TRUE`'s) remain.

This is done similarly in 2 dimensional data structures. The command below selects the rows where the `genes$Count` column equal to 0. 

```{r, eval=FALSE}
genes[genes$Count == 0,]
```

The code below will output the ROWS where the `Count` column is equal to 0 and all the COLUMNS (because no input is given after the comma). As there are many rows with a `genes$Count` of 0, I'll use the `head()` function to show just the first 6 rows of the output:

```{r}
head(genes[genes$Count == 0, ])
```

If you add `!` to the start of the `genes$Count == 0` condition statement, you will get all the rows where `genes$Count` is NOT equal to 0. 

Another way to think about it is that `genes$Count == 0` gives you a logical vector of 200 `TRUE`'s and `FALSE`'s and `!` flips everything such that the `TRUE`'s become `FALSE`'s and vice versa.

We do this here and print the first 6 rows of the output:

```{r}
head(genes[! genes$Count == 0,])
```

We can use the `$` shortcut to obtain just one column in a dataframe. We can't do this with matrices - we have to use the `[ ]` notation instead. 

For example, we can create a matrix from our `genes` dataframe. Recall that a matrix can only hold data of ONE data type - thus we will create a dataframe using just the `GeneLength` and `Count` columns of the `genes` dataframe. The first 6 rows are printed out:

```{r}
gene_matrix <- as.matrix(genes[,c(4,5)])
head(gene_matrix)
```

If we wanted just the rows where `Count` was equal to 0, this is the notation we could use:

```{r}
head(
  gene_matrix[gene_matrix[,2] == 0, ]
)
```

We used the `[ ]` to specify that we want to use the 2nd column of the matrix, which is the `Count` column. Like above, the `==` checks if each element in the `Count` column is 0. There is nothing entered to the right of the comma, indicating that we want all the columns.

**Challenge 2.1**

1. Subset the `genes` dataframe to obtain the rows where the `Count` is less than or equal to 10 and the columns `TXCHROM` and `Count`.
2. The function `is.na()` checks if each element in a vector is `NA`:

```{r}
is.na(c(2,5, NA))
```

Use this function to subset the `genes` dataframe so that all rows where `TXCHROM` column is `NA` is removed.

3. Using the dataframe from above subset to get only the rows where the `TXCHROM` is 'chr1' and all columns. 

*Hint*: you can refer to section \@ref(comps) to check how to perform different types of comparisons in R.

### %in%

In the last challenge, we used `==` to obtain the rows where `TXCHROM` is 'chr1'. Another way to perform 'matching' tasks is with the `%in%` function.

The following command subsets the rows where `TXCHROM` is "chr1" or "chr2" and prints out the first 6 rows.

```{r}
head(
  genes[genes$TXCHROM %in% c("chr1", "chr2"),]
  )
```

**Challenge 2.2**

There is an important difference between `==` and `%in%`.

Let's start by creating a vector of numbers:

```{r}
vect1 <- c(10,10,5,5,8,8)
```

We check which elements in our vector is equal to 5.

```{r}
vect1 == 5
```

The output is what we would expect.

What if we wanted check which elements are equal to 5 OR 10? We might try something like this, where put the numbers we are checking for in a vector:

```{r}
vect1
vect1 == c(5,10)
```

This isn't the output we expected.

Let's try the same task with `%in%`:

```{r}
vect1 %in% c(5,10)
```

This output IS what we want.

Take a look at the code above and see if you can understand what `==` does and what `%in%` does.


*Hint*: The story gets even more interesting if we try to use `==` to look for four numbers:

```{r}
vect1 == c(5,10,1,3)
```

This warning message may seem a bit cryptic. The 'longer' object it is referring to is `vect1` which has 6 elements. The shorter object it is referring to is `c(5,10,1,3)`, which has 4 elements. Thus, it is saying that 6 is not a multiple of 4. The reason R wants the longer object to be a multiple of the shorter one, is key to understanding what is happening when we use `==`.

## Vectorisation {#vect}

R is quite efficient at doing calculations or performing a functions on a vector of data.

Let's use the `Count` column from our dataframe `genes`. We can access just one column using the `$` symbol:

```{r}
genes$Count
```

What do you think will happen if we do this?

```{r}
genes$Count + 10
```

R will perform this calculation on all numbers in the `Count` column and return a vector.

We can add this new vector to our dataframe, as a new column.

```{r}
genes$Count_2 <- genes$Count + 10
```

There are a few things happening in the above code: 

1. The code on the right side of `<-` is evaluated first. It returns a vector as we saw above.
2. This vector is assigned to a column in `genes` called `Count_2`. Since this column does not yet exist in the `genes` dataframe, a new column called `Count_2` is created first. (If there was already a column name `Count_2`, this command will have overwritten that column with the new vector created in the right side of `<-`)

Note that you could also REPLACE a column using the same notation. For example, if, in the command above, the left side was `genes$Count`, the old column called `Count` would be REPLACED with the new vector of numbers created on the right side.

**Challenge 2.3**

Create a new column called `Prop_Count` that contains each count value as a proportion of the total count value of all 10 genes in the dataframe. E.g. if `Count` was 10 and total count of all 10 genes is 100, that row in `Prop_Count` should be 0.1.

*Hint* use the `sum()` function.

## Functions

A function, as the name suggests performs a function. We have already used many functions. For example, the `read.delim()` function reads in data, the `sum()` function adds numbers up and the `merge()` function above merges two dataframes.

Formally, when using a function, brackets (`( )`) are always included after the name of the function. Within the brackets is where input (technically 'arguments') to the function goes. You can find out what inputs an argument takes by looking at the help file.

For example, let's take a look at the `rnorm()` function help file. This function generates a random number from a normal distribution.

```{r rnorm, fig.cap='rnorm help file.', out.width="600px", echo=FALSE, fig.align='center'}
knitr::include_graphics("Images/rnorm_help.png")
```

We can see from the help file that `rnorm()` takes in 3 arguments:

```
rnorm(n, mean = 0, sd = 1)
```

The help file also tells us what each of these arguments does:

```
n	- number of observations. If length(n) > 1, the length is taken to be the number required.
mean - vector of means.
sd - vector of standard deviations.
```

**Challenge 2.3**

1. Take a look at what the `rnorm()` function outputs in the code below. Try using various different inputs to the function then, try to answer the following questions:

* What does `rnorm()` do when you only give it one number to the `mean` and `sd` arguments?
* What happens when you give either argument a vector of numbers?

```{r}
rnorm(4, mean = 10, sd = 1)
rnorm(3, mean = c(100,0), sd = 1)
```

2. Take a look at the following code:

```{r}
rnorm(3,1,10)
rnorm(10,1,3)
rnorm(3, mean = 10, sd = 0)
rnorm(sd = 10, mean = 0, n = 3)
```

How does the order of the arguments you input to the function affect the output? How does the order of the arguments you input affect the output, when you name each argument (along with the input)?

Note: as the function generates a random number, the numbers you will get from running the function will be different to the ones generated above.

## Homework

1. Subset your `genes` dataframe to obtain the rows 5 to 10, 45 and 72 and all the columns EXCEPT column 4.
2. Subset your `genes` dataframe to obtain only rows where genes with the symbol is "Rab18", "Ripk1" or "Xpr1" and all the columns.
3. Read in the data file "Ses2_homework.tsv" using `read.delim()`. Create a new column called `Prop_GeneLength` that contains the `Count` value as a proportion of `GeneLength`. E.g. if the count value was 50 and the gene length was 2400, the `Prop_GeneLength` value for that row would be 0.02083333. Finally, write out this new dataframe as a file called "Ses2_homework_output.tsv", as a tsv (tab separated values) file.
4. We will use the Bioconductor packages 'limma' and 'edgeR' in the next session. Install these packages with the following commands:

```{r, eval=FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install(c("edgeR", "limma"), version = "3.8")
```


## Answers

**Challenge 2.1**

1. This code obtains rows where `Count` is less than or equal to 10 and prints the first 6 rows using `head()`:

```{r}
head(genes[genes$Count <= 10,])
```

2. This code removes all rows where the `TXCHROM` column has a NA value (keeping all columns) and prints the first 6 rows:

```{r}
head(genes[! is.na(genes$TXCHROM),])
```

3. First we save the dataframe from the above as a variable called `genes_noNA`, then we subset to get only the rows where `TXCHROM` is 'chr1'. Again we only print the first 6 rows of this output.

```{r}
genes_noNA <- genes[! is.na(genes$TXCHROM),]

head(genes_noNA[genes_noNA$TXCHROM == "chr1",])
```

**Challenge 2.2**

What `==` does is compare `vect1` with `c(5,10)` one by one. Since `c(5,10)` only has two elements, R repeats this shorter vector until it is the same length as the longer vector. This is called 'recycling'. 

Thus, the comparisons being made is the top row with each corresponding value in the bottom row, with the result being shown in the third row:

```
10     10    5    5     8     8

5      10    5    10    5    10 

FALSE TRUE TRUE FALSE FALSE FALSE
```

R gives you a warning whenever the length of the shorter vector is NOT a multiple of the longer vector. 

When there were 4 elements in the shorter vector, it was not repeated a whole number of times - it was repeated 1.5 times. The comparisons being made between `vect1` and `c(5,10,1,3)` are:

```
10     10    5    5     8     8

5      10    1    3     5    10 

FALSE TRUE FALSE FALSE FALSE FALSE
```

`%in%` simply performs matching and does not take order of the two vectors into consideration. It checks whether the values in `vect1` matches either number in `c(5,10)`. It thus gives us the result we expect.

**Challenge 2.3**

1. If you provide `rnorm()` with a vector of inputs to either the `mean` or `sd` argument, it will use each element in that vector for successive random numbers generated and recycle the vector if it is shorter than the number of random numbers required.

Thus, the following code:

```{r, eval=FALSE}
rnorm(3, mean = c(100,0), sd = 1)
```

will generate 3 random numbers from the following normal distributions, in order:

```
1. mean of 100 and sd of 1
2. mean of 0 and sd of 1
3. mean of 100 and sd of 1
```

2. If you do not provide the name of the argument, `rnorm()` will use the first number provided as the argument to `n`, the second number provided as the input to `mean` and the third number provided as the input to `sd`.

Thus, `rnorm(3,1,10)` generates 3 random numbers from a normal distribution with a mean of 1 and a standard deviation of 10 and `rnorm(3,10,1)` will generate 3 random numbers from a normal distribution with a mean of 10 and a standard deviation of 1.

If you give the argument name with the input, it does not matter what order you provide the inputs.










